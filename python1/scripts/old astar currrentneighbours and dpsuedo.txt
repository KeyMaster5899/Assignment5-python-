old currentneighbours

#tentativeGscore = 0
#for x in range(-1,2):
#	for y in range(-1,2):
#		gx=current.gpos['x']+x
#		gy=current.gpos['y']+y
#		if(gx<0):gx=0
#		if(gy<0):gy=0
#		if(gx>48):gx=48
#		if(gy>26):gy=26
#		tile = tiles[gx][gy]
#		if(x or y) and (tile.state!=4):					
#			tentativeGscore = current.Gscore + self.distancebetween(current, tile)
#			if tile in self.closedList and tentativeGscore >= tile.Gscore:
#				continue
#				
#			if tile not in self.closedList or tentativeGscore < tile.Gscore:
#				self.camefrom[tile]=current
#				
#				if(tile.pos['x']==current.pos['x'] and tile.pos['y']!=current.pos['y']) or (
#						tile.pos['y']==current.pos['y'] and tile.pos['x']!=current.pos['x']):
#					tile.Gscore = tile.Gscore + 10
#				else:
#					tile.Gscore = tile.Gscore+ 14
#				tile.Fscore = tile.Gscore + tile.Hscore
#				if (tile not in self.openList):
#					self.openList.append(tile)


def distancebetween(self, current, tile):
		nx = current.pos['x'] - tile.pos['x']
		ny = current.pos['y'] - tile.pos['y']
		nx *= nx
		ny *= ny
		return math.sqrt(nx+ny)
		
		
		
		
		
#q=[]
	#for each tile in levelTile 
		#dist = inf
		#prev = None
		#q.append(tile)
	#start.dist=0
	
	#while q
		#u = sorted(q, key=attrgetter('dist'))[0]
		#q.remove(u)
		#if(u==end)
			#while u.parent!=None
				#u.setstate(5)
				#u=u.parent
			#break
		#if(u.dist==inf)
			#break
		
		#for x in range(-1,2):
			#for y in range(-1,2):
				#alt = u.dist + distance(u, levelTile[x][y])
				#if(alt<levelTiles[x][y].dist)
					#levelTiles[x][y].dist = alt
					#levelTiles[x][y].parent = u
					#???? decrease key(levelTiles[x][y]) in q